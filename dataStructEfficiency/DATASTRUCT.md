Checks how well multiple data structures perform

Each Map contains implementation map.h which sets the base class for each specific derived class. This header file contains a pair called Entry, which is uesd as the Entries inn every implementation of the map. It also contains an extern const Entry NONE; which is used as the default return value if a search cannot produce a result. After these, the base class Map is defined. This class contains 3 virtual functions. One to insert, one to search, and one to dump. It also contains a virtual deconsrtctor. After the base class is defined all the derived classes are listed. Thee are all the different implementations of the Map. These include UnsortedMap, SortedMap, BSTMap, RBTreeMap, and TreapMap. All of these inherit from the base class map. Each choose different wasy to implement the insert, search, and dump functions. Unsorted and sorted both use a vector to store the entries while BST RBTree and Treap all use a tree to store the Entries. ATreap contains additional methods to search, insert, and dump. It also contians a method to get the max hieght of the tree, the min height of the tree, and to print the pre-order traversal.

The map_test.cpp is used to test insert and search on a specific backend implementation. This function essesntially takes in the infro from the user to determine which backend to use, then it creates a map using that backends, and checks whether this is done correctly. The map_bench funcation times how long it takes to insert and search given a specific backend. It times these and displays the time for the user

Treap was implemented by completing the methods described above. The insert method was completed by making a helper function so it could be recursive. THis function took in a node, key, and value. To call the function the root node was called along with the key and vale that was to be placed. This function is closely related to teh insert_r function used for the BST. IF the node passed in was NULL, ad new Node was allocated using the Node constructor. This node was given the value and key passed to the function and a priority level generated by the helper function get_random)_ which returns a random int If this did not happen that other if statements were used. If the key equal the key of the node passed in, then the value of that node was altered to the value being passed in. If the key is less than the node->key then the left node is set equal to the recursive call of insert(left node). The difference from BST comes next. The if left node priority is greater than the node priority then the node is set euql to the helper funciton rotateRight(node). After this the method handles the case if the key was greater than the node->key. If thats the case then the same methods happen as if it were less than, but with the right node instead of the left one.

The rotateRight and rotateLeft helper functiosn are used to effectively rotate the tree given the node of the tree.

This search of the the treap was implemented in the exact same wasy as the BST. The heper function is the exact same as search_r, except its called search_t.

Thde dump method is implmented by using the function dump_r. This function is located in BST, but is claled hear as an extern function. This essentially dumps the keys and values of the tree to a stream given the specificed DumpFlag.

THe getMaxTreeHeight method is used by calling the getMaxTreeHeightHelp helper function which is passed the pointer to the root node (like every other function).This function works by return 0 if the node is null. If not then the left size of the tree is stored by recursively calling the function on node->left and the right size of the tree is stroed by reucrsively calling the funtion on node->right. THen the larger of the two sides + 1 is returned

THe getMinTreeHeight method is implemented by calling the getMinTreeHeight helper function. This function returns 0 if the pointer is null, and returns one if the left and right nodes are null. THen the depth of the ight side is foundif the left side is null by returning the recursive call of getMinTreeHeightHelp(node->right) + 1. The same is done to but with node->left after this to return the depth of the left side. Finally, after these if statements, return min(getMinTreeHeightHelp(node->left), etMinTreeHeightHelp(node->right)) + 1 is called to return the minimum height.

The preOrderTreaversal method is implemented by recuresively calling a preOrderTraversalHelp functon with is passed the root node. This function returns if the node is null. after that it prints the key value of the node. Then it recursively calls the funciton of node->left. And finally it recursively calls the funcion on node->right 

Benchmarking for n = 30,000 ...
== Unsorted ==
Insert: 31.789 s
Search: 30.588 s
== Sorted == 
Insert: 41.695 s
Search: 0.062821 s
== BST == 
Insert: 33.369 s
Search: 31.134 s
== RBTree == 
Insert: 0.066018 s
Search: 0.043484 s
== Treap == 
Insert: 0.048505 s
Search: 0.05183 s

Treap performed the best out of all the implementatiosns except that RB Tree is slightly faster at searching.Unsorted and BST perforemed pretty poorly in the insert and search category. Sorted performed the slowest in insert, but fairly fst in search
