Date: 2/23/2017
Author: Will Fritz

From the user's perspective this program is meant to solve a 9x9 sudoku puzzle. The user is prompted to enter the name of a file containing a 9x9 unifinished board. For unknown values the spot on the board should be 0. Examle row on board in file: 0 3 2 0 0 8 9 1 4. Once the user types in the files name and presses enter, the program should return a solved board in the same format as above, but instead of the 0's, the correcty numerical value between 1 and 9 will be there instead. 

The files that can be tested here are valid suduko boards. They are named inpute.txt (easy difficulty), inputm.txt (medium difficulty), inputh.txt (hard difficulty),  and hardest.txt (really hard puzzle). The idea here is that the solver can solve a lot of boards given the correct input. A user can make their own input file in the format demostrated in the txt files in this directory and then use the program to generate a solution for that board

The srtucture of the program is fairly simple. A single file is used called Solver.cpp. THis file has a declared struct called Cell which stores an int value and an array of bools of length 9. The main function then asks for the user's file name and gives an error if there is no file found. Ifstream is used to check this, and then used to open the file if it can be found. The object created from the open file is then used to populate a 2D array of Cells (the struct) called board. This population sets each cell value to the value read in from the ifstream object. It also sets the array of bools to true for every position (0-8) for every cell .this is essentially saying that any value is valid for that specific cell (which is not necessarily true but that will be changed later. After populating in the main, a while loop is used to continually call three functions until the puzzle is solved. One checks if the puzzle is solved by making sure no zeros are on the cell values for every cell in the board. Another function is used to fill in values. This function fills in values by reading the array of bools and checking if only one of the cvalues is true. If that is the case, that speciifc Cell value is set to the appropriate number based on the array of bool's. The final function called fillBool calls multiple other functions. These functions come in two forms, singleton and eliminate. Three eliminate funtions were written (row, column, and grid)/ These functions checked the row column and girid of a specific cell and set the Cell's bool array to false at the appropriatte spot according to the rules of sudoku. It essentially checks the values of every other cell in tthe row, column, or grid, and uses that info to set the positions of the bool array of the original Cell to false. There are two functions (one for rows and one for columns)that implement the singleton idea. These essentially check each cell's bool array to see what values it can be. This value is then checked with the other bool arrays of the cells in the row or column depending on the function. If the initial Cell has a unique array position, then that position is used to set the value of the original cell

I evaluated the program by first checking it against the two sudoku puzzles provided by the class. I validated the output my program produced by running the same puzzles through online simulators. They all produced the same values as mine so I knew that my program worked. I then continued to search the web for harder and harder puzzles. Ths program prooduces the correct result for most of them, but not all (searched the hardest sudoku puzzle in the world and the program could not solve it ]: ). When tested against really hard puzzles, the program essentially solved to a certain point and then got stuck, but coud never produce a result since the while loop runs until all values are filled

HWile writing this program, the hardest part for me was figuring out how to set it up. I did not know whether to create a class, or use multiple calsses, but in the end all that was needed was a simple struct and a few functions. Also, I found myself using multiple for loops, which scared me at first, however, really making sure my indices were correct allowed for all the loops The solver was implemented by basically running the folllowing pattern: 

    1. If a cell has a value, set the bool array for that cell to false at all positions except that value
    2. Fill the bool arrays with 'false' by using both eingleton and elimination functions
    3. Fill the cell values in by cecking the bool array for each cell and seing either which position was unique compared to other cells in the row or column (sigleton) or by setting it to the only value remaining in the bool array (elimination method)

This pattern was repeated until a valid soultion was found (no zeros for all cells in the 2D array called board). Esentially, sudoku ologic was combined with the power of for loops (checking MANY combinations) to eventually produce a solved sudoku puzzle     
